---
title: "ãƒ–ãƒ­ã‚°ã‚’Next.js 13ã«ç§»è¡Œã—ãŸ"
date: 2023-03-03
description: "React Server Component / App Router ã«å¯¾å¿œ"
tags: ["tech", "web", "nextjs", "react"]
emoji: "ğŸ“"
related: ["blog-renewal"]
---

## ã¯ã˜ã‚ã«

:tada: Next.js 13.2 ãŒãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã€App Router (beta) & React Server Componentï¼ˆä»¥ä¸‹ RSCï¼‰ãŒå®Ÿç”¨ã§ããã†ãªæ„Ÿã˜ã«ãªã£ã¦ããŸãŸã‚ã€ã“ã®ã‚µã‚¤ãƒˆã‚‚ç§»è¡Œã—ãŸã€‚Metadata APIã€Route Handler ç­‰ã‚‚åŒæ™‚ã«å°å…¥ã—ãŸã€‚

https://github.com/haxibami/haxibami.net

## ã‚„ã£ãŸã“ã¨

ï¼ˆä¸€èˆ¬çš„ãªè¨­å®šã«ã¤ã„ã¦ã¯[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://nextjs.org/docs/app)ç­‰ã‚’å‚ç…§ï¼‰

### next.config.js

```js title="next.config.mjs" {5-11}
/** @type {import('next').NextConfig} */
let nextConfig = {
  reactStrictMode: true,
  experimental: {
    serverComponentsExternalPackages: [
      "playwright",
      "svgo",
      "plaiceholder",
      "@plaiceholder/next",
      "fetch-site-metadata",
    ],
    scrollRestoration: true,
    appDir: true,
  },
  images: {
    formats: ["image/avif", "image/webp"],
    domains: ["asciinema.org", "raw.githubusercontent.com"],
  },
};
```

`experimental.serverComponentsExternalPackages`ã¨ã„ã†é …ç›®ãŒã‘ã£ã“ã†é‡è¦ã€‚Markdown ã®å‡¦ç†ã« node ä¾å­˜ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã€è©²å½“ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã“ã“ã«åˆ—æŒ™ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚

https://nextjs.org/docs/app/api-reference/next-config-js/serverComponentsExternalPackages

ã‚ã¨é–¢ä¿‚ãªã„ãŒ `next.config.js` ã¯ãƒ‰ã‚·ãƒ‰ã‚· ESMï¼ˆ`.mjs`ï¼‰ã§æ›¸ã“ã†ã€‚

### Markdown / MDX ã®å‡¦ç†

[å…¬å¼ãƒ–ãƒ­ã‚°](https://nextjs.org/blog/next-13-2)ã‚’è¦‹ã‚‹é™ã‚Šã€`@next/mdx`ã€`next-mdx-remote`ã€`contentlayer`ã®ä¸‰è€…ã¯ç¾æ™‚ç‚¹ï¼ˆ2023/03/03ï¼‰ã§ RSC ã§åˆ©ç”¨ã§ãã‚‹ã€‚

https://github.com/hashicorp/next-mdx-remote

https://contentlayer.dev

`next-mdx-remote/rsc`ã‚’ä½¿ã£ãŸã¨ã“ã‚ã€å…¥å‡ºåŠ›ã®ä»•æ§˜ãŒå¾®å¦™ã«å¤‰æ›´ã•ã‚Œã¦ã„ãŸã€‚`compileMDX` ã§ JSX ã‚’ç›´æ¥åã‹ã›ã‚‹ã‹ã€`<MDXRemote>`ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã« Markdown / MDX ã‚’é£Ÿã‚ã›ã‚‹ã‹é¸ã¹ã‚‹ï¼ˆãŠãã‚‰ãã©ã¡ã‚‰ã§ã‚‚å‡ºåŠ›ã«å·®ã¯ãªã„ï¼‰ã€‚

ãã®ã»ã‹ã€frontmatter ã«å‹ã‚’ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚

```ts title="lib/compiler.ts" {41-47}
import { compileMDX } from "next-mdx-remote/rsc";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import rehypeKatex from "rehype-katex";
import rehypePrettyCode from "rehype-pretty-code";
import rehypeRaw from "rehype-raw";
import rehypeSlug from "rehype-slug";
import remarkGemoji from "remark-gemoji";
import remarkGfm from "remark-gfm";
import remarkJaruby from "remark-jaruby";
import remarkMath from "remark-math";
import remarkUnwrapImages from "remark-unwrap-images";

import MDXComponent from "components/MDXComponent";
import rehypeImageOpt from "lib/rehype-image-opt";
import { remarkLinkCard, extLinkHandler } from "lib/remark-link-card";
import remarkMermaid from "lib/remark-mermaid";

import type { Options } from "rehype-pretty-code";

const rpcOptions: Partial<Options> = {
  theme: {
    light: "poimandres",
  },
  keepBackground: true,
  onVisitLine(node) {
    if (node.children.length === 0) {
      node.children = [{ type: "text", value: " " }];
    }
  },
  onVisitHighlightedLine(node) {
    node.properties.className.push("highlighted");
  },
  onVisitHighlightedWord(node) {
    node.properties.className = ["word"];
  },
};

const compiler = async (source: string) => {
  const result: Promise<{
    content: JSX.Element;
    frontmatter: {
      slug: string;
      title: string;
      date: string;
      description: string;
      tags: string[];
    };
  }> = compileMDX({
    source,
    components: MDXComponent,
    options: {
      mdxOptions: {
        remarkPlugins: [
          remarkGfm,
          remarkGemoji,
          remarkMath,
          remarkJaruby,
          remarkLinkCard,
          remarkUnwrapImages,
          [
            remarkMermaid,
            {
              wrap: true,
              className: ["mermaid"],
            },
          ],
        ],
        rehypePlugins: [
          rehypeSlug,
          [rehypeAutolinkHeadings, { behavior: "wrap" }],
          rehypeKatex,
          [rehypePrettyCode, rpcOptions],
          rehypeImageOpt,
          rehypeRaw,
        ],
        remarkRehypeOptions: {
          handlers: {
            extlink: extLinkHandler,
          },
        },
        format: "md",
      },
      parseFrontmatter: true,
    },
  });
  return result;
};

export default compiler;
```

### Route Handler ã«ã‚ˆã‚‹ OG ç”»åƒç”Ÿæˆ

Next.js 13.2 ã§ API Routes ã‚’ä»£æ›¿ã™ã‚‹ Route Handler ãŒç™»å ´ã—ãŸãŸã‚ã€ã¤ã„ã«[OG ç”»åƒç”Ÿæˆ](/blog/posts/blog-renewal#og-ç”»åƒã®ç”Ÿæˆ)ã§ä½¿ã£ã¦ã„ãŸ `pages` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å®Œå…¨ã«å»ƒæ­¢[^1]ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚

[^1]: å³å¯†ã«ã¯ `404.js` ãŒã¾ã æ®‹ã£ã¦ã„ã‚‹ãŒã€ã“ã¡ã‚‰ã§æ›¸ã‹ãªãã¦ã‚‚å‡¦ç†ã•ã‚Œã‚‹ã®ã§ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè‡ªä½“ã¯å‰Šé™¤å¯èƒ½

https://nextjs.org/docs/app/building-your-application/routing/router-handlers

```tsx title="app/api/ogp/route.tsx"
import type { NextRequest } from "next/server";

import { ImageResponse } from "@vercel/og";

export const runtime = "edge";

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const titleQ = searchParams.has("title")
      ? searchParams.get("title")?.slice(0, 80)
      : "";
    const dateQ = searchParams.has("date")
      ? `ğŸ“… â€• ${searchParams.get("date")?.slice(0, 8)}`
      : "";

    // sanitize title & date
    const title = titleQ?.endsWith(".png") ? titleQ.slice(0, -4) : titleQ;
    const date = dateQ?.endsWith(".png") ? dateQ.slice(0, -4) : dateQ;

    // CJK font is so large that if placed locally it easily exceeds the 1MB Edge Function limit >_<
    const notoFontData = await fetch(
      "https://rawcdn.githack.com/haxibami/Noto-Sans-CJK-JP/master/fonts/NotoSansCJKjp-Bold.woff",
    ).then((res) => res.arrayBuffer());

    const robotoFontData = await fetch(
      new URL("../../../assets/RobotoMono-Medium.woff", import.meta.url),
    ).then((res) => res.arrayBuffer());

    const iconBuffer = await fetch(
      new URL("../../../assets/kripcat.jpg", import.meta.url),
    ).then((res) => res.arrayBuffer());

    const icon = Buffer.from(
      String.fromCharCode(...new Uint8Array(iconBuffer)),
      "binary",
    ).toString("base64");

    return new ImageResponse(
      (
        <div
          style={{
            height: "100%",
            width: "100%",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            padding: "30px",
            fontFamily: "Noto Sans CJK JP",
            backgroundColor: "#120e12",
            color: "#f2f0e6",
          }}
        >
          <div tw="flex flex-col p-12 w-full h-full border-solid border-4 border-white rounded-xl">
            <div tw="flex flex-1 max-w-full items-center max-h-full">
              <h1 tw="text-6xl leading-tight max-w-full">
                <p tw="w-full justify-center">{title}</p>
              </h1>
            </div>
            <div tw="flex flex-row justify-between items-center w-full">
              <div tw="flex items-center">
                {/* eslint-disable-next-line @next/next/no-img-element */}
                <img
                  src={`data:image/png;base64,${icon}`}
                  alt="haxicon"
                  width={100}
                  height={100}
                  tw="rounded-full mr-5"
                />
                <h2 tw="text-4xl mr-5">
                  <p
                    style={{
                      fontFamily: "Roboto Mono",
                    }}
                  >
                    haxibami.net
                  </p>
                </h2>
              </div>
              <div tw="flex">
                <h2 tw="text-4xl">
                  <p>{date}</p>
                </h2>
              </div>
            </div>
          </div>
        </div>
      ),
      {
        fonts: [
          {
            name: "Noto Sans CJK JP",
            data: notoFontData,
            weight: 700,
            style: "normal",
          },
          {
            name: "Roboto Mono",
            data: robotoFontData,
            weight: 500,
            style: "normal",
          },
        ],
      },
    );
  } catch (e) {
    console.log(`${e}`);
    return new Response(`Failed to generate the image`, {
      status: 500,
    });
  }
}
```

### Metadata API

åŒã˜ã Next.js 13.2 ã§ç™»å ´ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆé€šã‚Šã«ã‚„ã‚‹ã ã‘ã€‚

ã‚µã‚¤ãƒˆãƒãƒƒãƒ—ã¯ã€ãƒ“ãƒ«ãƒ‰å‰ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦ãŠã„ãŸè¨˜äº‹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åŸºã¥ã„ã¦ç”Ÿæˆã™ã‚‹ã‚ˆã†ã«ã—ã¦ã‚ã‚‹ã€‚

```ts title="hooks/scripts/indexer.mts"
import fs from "fs";

import prettier from "prettier";

import { getPostsData, getTags } from "./lib/fs.js";

import type { PostData } from "./lib/interface.js";

const articleIndexer = async () => {
  const blogs = await getPostsData("articles/blog");
  const blogIndex = blogs.map((item) => {
    const indexitem: PostData = {
      preview: item.preview,
      data: {
        slug: `${item.data?.slug}`,
        title: `${item.data?.title}`,
        date: item.data?.date,
        description: `${item.data?.description}`,
        tags: item.data?.tags,
      },
    };
    return indexitem;
  });

  const blogTags = await getTags("articles/blog");

  const index = {
    articles: {
      blog: blogIndex,
    },
    tags: {
      blog: blogTags,
    },
  };

  const formatted = (json: string) => prettier.format(json, { parser: "json" });

  fs.writeFileSync("src/share/index.json", formatted(JSON.stringify(index)));
};
```

```ts title="src/app/sitemap.ts"
import type { MetadataRoute } from "next";

import { globby } from "globby";

import { dateConverter } from "lib/build";
import { HOST } from "lib/constant";
// Article index file
import postIndex from "share/index.json";

import type { PostData } from "lib/interface";

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const constPaths = await globby(["src/app/**/page.tsx", "src/app/page.tsx"], {
    ignore: ["src/app/api/*.tsx", "src/app/grad_essay/**", "src/app/**/[*/**"],
  });

  const constPageEntries = constPaths.map((filePath) => {
    const constPageEntry = {
      relpath: filePath.replace("src/app/", "").replace("page.tsx", ""),
      lastmod: "",
    };
    return constPageEntry;
  });

  const blogposts = postIndex.articles.blog;

  const blogTags = postIndex.tags.blog;

  const blogEntries = blogposts.map((post: PostData) => {
    const blogEntry = {
      relpath: `blog/posts/${post.data?.slug}`,
      lastmod: dateConverter(post.data?.date),
    };
    return blogEntry;
  });

  const blogTagEntries = blogTags.map((tag: string) => {
    const blogTagEntry = {
      relpath: `blog/tag/${tag}`,
      lastmod: "",
    };
    return blogTagEntry;
  });

  const sitemapEntries = constPageEntries.concat(blogEntries, blogTagEntries);
  return sitemapEntries.map((entry) =>
    entry.lastmod !== ""
      ? {
          url: `https://${HOST}/${entry.relpath}`,
          lastModified: entry.lastmod,
        }
      : {
          url: `https://${HOST}/${entry.relpath}`,
        },
  );
}
```

## æ‰€æ„Ÿ

å®Œå…¨ãªé™çš„ã‚µã‚¤ãƒˆã‚†ãˆã€å®Ÿã®ã¨ã“ã‚ãã‚Œã»ã©å¤‰åŒ–ã¯ãªã„ã€‚ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºã¯å¤šå°‘å°ã•ããªã£ãŸã‹ã‚‚ã€‚

![ãƒ“ãƒ«ãƒ‰çµæœ](/image/bundlesize_next13.png)

ã¡ãªã¿ã« Lighthouse ã¯ã“ã‚“ãªæ„Ÿã˜ï¼š

![ãƒˆãƒƒãƒ—](/image/lighthouse_0.png)

![ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«](/image/lighthouse_1.png)

![ã“ã®è¨˜äº‹](/image/lighthouse_2.png)
